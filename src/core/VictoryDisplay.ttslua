local playAreaApi = require("core/PlayAreaApi")
local tokenChecker = require("core/token/TokenChecker")
local pendingCall = false
local messageSent = {}
local missingData = {}
local countedVP   = {}
local highlightMissing = false
local highlightCounted = false
local TRASHCAN
local TRASHCAN_GUID = "70b9f6"
local chaosBagApi = require("chaosbag/ChaosBagApi")

-- button creation when loading the game
function onLoad()
  TRASHCAN = getObjectFromGUID(TRASHCAN_GUID)

  -- index 0: VP - "Display"
  local buttonParameters          = {}
  buttonParameters.label          = "0"
  buttonParameters.click_function = "none"
  buttonParameters.function_owner = self
  buttonParameters.scale          = { 0.15, 0.15, 0.15 }
  buttonParameters.width          = 0
  buttonParameters.height         = 0
  buttonParameters.font_size      = 600
  buttonParameters.font_color     = { 1, 1, 1 }
  buttonParameters.position       = { x = -0.72, y = 0.06, z = -0.69 }
  self.createButton(buttonParameters)

  -- index 1: VP - "Play Area"
  buttonParameters.position.x = 0.65
  self.createButton(buttonParameters)

  -- index 2: VP - "Total"
  buttonParameters.position.x = 1.69
  self.createButton(buttonParameters)

  -- index 3: highlighting button (missing data)
  self.createButton({
    label          = "!",
    click_function = "highlightMissingData",
    tooltip        = "Enable highlighting of cards without metadata (VP on these is not counted).",
    function_owner = self,
    scale          = { 0.15, 0.15, 0.15 },
    color          = { 1, 0, 0 },
    width          = 700,
    height         = 800,
    font_size      = 700,
    font_color     = { 1, 1, 1 },
    position       = { x = 1.82, y = 0.06, z = -1.32 }
  })

  -- index 4: highlighting button (counted VP)
  self.createButton({
    label          = "?",
    click_function = "highlightCountedVP",
    tooltip        = "Enable highlighting of cards with VP.",
    function_owner = self,
    scale          = { 0.15, 0.15, 0.15 },
    color          = { 0, 1, 0 },
    width          = 700,
    height         = 800,
    font_size      = 700,
    font_color     = { 1, 1, 1 },
    position       = { x = 1.5, y = 0.06, z = -1.32 }
  })

  -- update the display label once
  Wait.time(updateCount, 1)
end

---------------------------------------------------------
-- events with descriptions
---------------------------------------------------------

-- dropping an object on the victory display
function onCollisionEnter()
  startUpdate()
end

-- removing an object from the victory display
function onCollisionExit()
  startUpdate()
end

-- picking a clue or location up
function onObjectPickUp(_, obj)
  maybeUpdate(obj)
end

-- dropping a clue or location
function onObjectDrop(_, obj)
  maybeUpdate(obj, 1)
end

-- flipping a clue/doom or location
function onObjectRotate(obj, _, flip, _, _, oldFlip)
  if flip == oldFlip then return end
  maybeUpdate(obj, 1, true)
end

-- destroying a clue or location
function onObjectDestroy(obj)
  maybeUpdate(obj)
end

---------------------------------------------------------
-- main functionality
---------------------------------------------------------

function maybeUpdate(obj, delay, flipped)
  -- stop if there is already an update call running
  if pendingCall then return end

  -- stop if obj is nil (by e.g. dropping a clue onto another and making a stack)
  if obj == nil then return end

  -- only continue for clues / doom tokens or locations
  if obj.hasTag("Location") then
  elseif obj.memo == "clueDoom" then
    -- only continue if the clue side is up or a doom token is being flipped
    if obj.is_face_down == true and flipped ~= true then return end
  else
    return
  end

  -- only continue if the obj in in the play area
  if not playAreaApi.isInPlayArea(obj) then return end

  startUpdate(delay)
end

-- starts an update
function startUpdate(delay)
  -- stop if there is already an update call running
  if pendingCall then return end
  pendingCall = true
  delay = tonumber(delay) or 0
  Wait.time(updateCount, delay + 0.2)
end

-- counts the VP in the victory display and request the VP count from the play area
function updateCount()
  missingData            = {}
  countedVP              = {}
  local victoryPoints    = {}
  victoryPoints.display  = 0
  victoryPoints.playArea = playAreaApi.countVP()

  -- count cards in victory display
  for _, v in ipairs(searchOnObj(self)) do
    local obj = v.hit_object

    -- check metadata for VP
    if obj.tag == "Card" then
      local VP = getCardVP(obj, JSON.decode(obj.getGMNotes()))
      victoryPoints.display = victoryPoints.display + VP
      if VP > 0 then
        table.insert(countedVP, obj)
      end

    -- handling for stacked cards
    elseif obj.tag == "Deck" then
      local VP = 0
      for _, deepObj in ipairs(obj.getObjects()) do
        local deepVP = getCardVP(obj, JSON.decode(deepObj.gm_notes))
        victoryPoints.display = victoryPoints.display + deepVP
        if deepVP > 0 then
          VP = VP + 1
        end
      end
      if VP > 0 then
        table.insert(countedVP, obj)
      end
    end
  end

  -- update the buttons that are used as labels
  self.editButton({ index = 0, label = victoryPoints.display })
  self.editButton({ index = 1, label = victoryPoints.playArea })
  self.editButton({ index = 2, label = victoryPoints.display + victoryPoints.playArea })

  -- allow new update calls
  pendingCall = false
end

-- gets the VP count from the notes
function getCardVP(obj, notes)
  local cardVP
  if notes ~= nil then
    -- enemy, treachery etc.
    cardVP = tonumber(notes.victory)

    -- location
    if not cardVP then
      -- check the correct side of the location
      if not obj.is_face_down and notes.locationFront ~= nil then
        cardVP = tonumber(notes.locationFront.victory)
      elseif notes.locationBack ~= nil then
        cardVP = tonumber(notes.locationBack.victory)
      end
    end
    if (cardVP or 0) > 0 then
      table.insert(countedVP, obj)
    end
  else
    table.insert(missingData, obj)
  end
  return cardVP or 0
end

-- toggles the highlight for objects with missing metadata
function highlightMissingData()
  self.editButton({
    index = 3,
    tooltip = (highlightMissing and "Enable" or "Disable") ..
        " highlighting of cards without metadata (VP on these is not counted)."
  })
  for _, obj in pairs(missingData) do
    if obj ~= nil then
      if highlightMissing then
        obj.highlightOff("Red")
      else
        obj.highlightOn("Red")
      end
    end
  end
  playAreaApi.highlightMissingData(highlightMissing)
  highlightMissing = not highlightMissing
end

-- toggles the highlight for objects that were counted
function highlightCountedVP()
  self.editButton({
    index = 4,
    tooltip = (highlightCounted and "Enable" or "Disable") ..
        " highlighting of cards with VP."
  })
  for _, obj in pairs(countedVP) do
    if obj ~= nil then
      if highlightCounted then
        obj.highlightOff("Green")
      else
        obj.highlightOn("Green")
      end
    end
  end
  playAreaApi.highlightCountedVP(highlightCounted)
  highlightCounted = not highlightCounted
end

-- places the provided card in the first empty spot
function placeCard(card)
  -- check snap point states
  local snaps = self.getSnapPoints()
  table.sort(snaps, function(a, b) return a.position.x > b.position.x end)
  table.sort(snaps, function(a, b) return a.position.z < b.position.z end)

  -- get first empty slot
  local fullSlots = {}
  local positions = {}
  for i, snap in ipairs(snaps) do
    positions[i] = self.positionToWorld(snap.position)
    local hits = checkSnapPointState(positions[i])

    -- first hit is self, additional hits must be cards / decks
    if #hits > 1 then
      fullSlots[i] = true
    end
  end

  -- remove tokens from the card
  for _, v in ipairs(searchOnObj(card)) do
    local obj = v.hit_object

    -- don't touch decks / cards
    if obj.tag == "Deck" or obj.tag == "Card" then
    -- put chaos tokens back into bag
    elseif tokenChecker.isChaosToken(obj) then
      local chaosBag = chaosBagApi.findChaosBag()
      chaosBag.putObject(obj)
    elseif obj.memo ~= nil and obj.getLock() == false then
      TRASHCAN.putObject(obj)
    end
  end
  
  -- place the card
  local name = card.getName() or "Unnamed card"
  for i = 1, 10 do
    if fullSlots[i] ~= true then
      local rot = { 0, 270, card.getRotation().z }
      card.setPositionSmooth(positions[i], false, true)
      card.setRotation(rot)
      broadcastToAll("Victory Display: " .. name .. " placed into slot " .. i .. ".", "Green")
      return
    end
  end

  broadcastToAll("Victory Display is full! " .. name .. " placed into slot 1.", "Orange")
  card.setPositionSmooth(positions[1], false, true)
end

---------------------------------------------------------
-- utility functions
---------------------------------------------------------

-- searches on an object
function searchOnObj(obj)
  return Physics.cast({
    direction    = { 0, 1, 0 },
    max_distance = 0.5,
    type         = 3,
    size         = obj.getBounds().size,
    origin       = obj.getPosition()
  })
end

function checkSnapPointState(pos)
  return Physics.cast({
    direction    = { 0, 1, 0 },
    max_distance = 0.1,
    type         = 3,
    size         = { 0.1, 0.1, 0.1 },
    origin       = pos
  })
end

-- search a table for a value, return true if found (else returns false)
function tableContains(table, value)
  for _, v in ipairs(table) do
    if v == value then
      return true
    end
  end
  return false
end
