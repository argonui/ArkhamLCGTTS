require("playercards/CardsWithHelper")
local blessCurseManagerApi = require("chaosbag/BlessCurseManagerApi")
local chaosBagApi          = require("chaosbag/ChaosBagApi")
local guidReferenceApi     = require("core/GUIDReferenceApi")
local playermatApi         = require("playermat/PlayermatApi")
local tokenArrangerApi     = require("tokens/TokenArrangerApi")

-- intentionally global
hasXML                     = true
isHelperEnabled            = false
local loopId

-- table to store state for matcolors (will hold GUID of sealed token)
local buttonData           = {
  White  = false,
  Orange = false,
  Green  = false,
  Red    = false
}

function updateSave()
  self.script_state = JSON.encode({
    isHelperEnabled = isHelperEnabled,
    buttonData      = buttonData,
    loopId          = loopId
  })
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    local loadedData = JSON.decode(savedData)
    isHelperEnabled  = loadedData.isHelperEnabled
    buttonData       = loadedData.buttonData
    loopId           = loadedData.loopId
  end
  if isHelperEnabled then updateDisplay() end
end

function initialize()
  maybeUpdateButtonState()
  loopId = Wait.time(maybeUpdateButtonState, 1, -1)
  self.addContextMenuItem("Release all tokens", releaseAllTokens)
end

function shutOff()
  if loopId then
    Wait.stop(loopId)
    loopId = nil
  end
  self.addContextMenuItem("Release all tokens", releaseAllTokens)
end

function resetSealedTokens()
  buttonData = {
    White  = false,
    Orange = false,
    Green  = false,
    Red    = false
  }
  updateSave()
end

function releaseAllTokens(playerColor)
  if not chaosBagApi.canTouchChaosTokens() then return end

  local chaosbag = chaosBagApi.findChaosBag()

  local count = 0
  for buttonId, state in pairs(buttonData) do
    if state then
      local token = getObjectFromGUID(state)
      if token then
        count = count + 1
        chaosbag.putObject(token)
        blessCurseManagerApi.releasedToken(token.getName(), state)
        state = false
      end
    end
  end

  if count == 0 then
    printToColor("No tokens to release found!", playerColor)
    return
  end

  local str = (count == 1) and "token" or "tokens"
  printToColor("Returning " .. count .. " " .. str .. " to the token pool", playerColor)

  tokenArrangerApi.layout()
  updateSave()
  Player[playerColor].clearSelectedObjects()
end

-- count tokens in the bag and maybe grey buttons
function maybeUpdateButtonState()
  local numInBag = blessCurseManagerApi.getBlessCurseInBag()
  noBlessAvailable = (numInBag.Bless == 0)

  local investigatorCards = playermatApi.getUsedInvestigatorCards()
  local tableLayoutHeight = 1800

  for buttonId, state in pairs(buttonData) do
    if investigatorCards[buttonId] then
      if noBlessAvailable and state == false then
        self.UI.setAttribute(buttonId, "color", getButtonColor("Inactive"))
        self.UI.setAttribute("Row_" .. buttonId, "active", true)
      else
        local handColor = playermatApi.getPlayerColor(buttonId)
        if handColor then
          self.UI.setAttribute(buttonId, "color", getButtonColor(handColor))
          self.UI.setAttribute("Row_" .. buttonId, "active", true)
        else
          self.UI.setAttribute("Row_" .. buttonId, "active", false)
          tableLayoutHeight = tableLayoutHeight - 450
        end
      end
    else
      self.UI.setAttribute("Row_" .. buttonId, "active", false)
      tableLayoutHeight = tableLayoutHeight - 450
    end

    -- update button text (free trigger vs reaction trigger)
    self.UI.setAttribute(buttonId, "text", state and "u" or "v")
  end

  -- update height of table layout
  self.UI.setAttribute("Helper", "height", tableLayoutHeight)
end

function onClick_sidebutton(player, clickType, buttonId)
  if buttonData[buttonId] == false then
    -- nothing sealed yet
    local numInBag = blessCurseManagerApi.getBlessCurseInBag()
    noBlessAvailable = (numInBag.Bless == 0)

    if noBlessAvailable then
      broadcastToColor("There are no bless tokens available for sealing.", player.color, "Orange")
      return
    end

    if not chaosBagApi.canTouchChaosTokens() then return end

    local chaosBag = chaosBagApi.findChaosBag()
    if not chaosBag then return end

    local sealPos = playermatApi.transformLocalPosition(Vector(-1.177, 0, 0.002), buttonId)
    local sealRot = playermatApi.returnRotation(buttonId)

    for i, obj in ipairs(chaosBag.getObjects()) do
      if obj.name == "Bless" then
        chaosBag.takeObject({
          position = sealPos + Vector(0, 0.5, 0),
          rotation = sealRot,
          index = i - 1,
          smooth = false,
          callback_function = function(token)
            local guid = token.getGUID()
            buttonData[buttonId] = guid

            local handColor = playermatApi.getPlayerColor(buttonId)
            broadcastToColor("Sealed bless for " .. handColor, player.color)

            maybeUpdateButtonState()
            updateSave()
            tokenArrangerApi.layout()
            blessCurseManagerApi.sealedToken("Bless", guid)
          end
        })
        break
      end
    end
  else
    -- bless token was sealed
    local mat = guidReferenceApi.getObjectByOwnerAndType(buttonId, "Playermat")
    local drawnToken = chaosBagApi.drawChaosToken(mat, true, _, buttonData[buttonId])
    if drawnToken then
      buttonData[buttonId] = false
      local handColor = playermatApi.getPlayerColor(buttonId)
      broadcastToColor("Resolved sealed bless for " .. Global.call("getColoredName", handColor), player.color)
      maybeUpdateButtonState()
      updateSave()
    else
      broadcastToColor("A different playermat still had tokens, returned them instead.", player.color, "Orange")
    end
  end
end

-- gets a hex color from a string and adds some transparency
function getButtonColor(colorStr)
  if colorStr == "Inactive" then
    return "#353535E6"
  end
  return "#" .. Color.fromString(colorStr):toHex() .. "e6"
end
